<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pinder.data.find_transitive_hits &#8212; pinder 0.1.dev1+g8ad1ead documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic_mod.css?v=59943e95" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=28804041" />
    <script src="../../../_static/documentation_options.js?v=40280a1a"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <script src="../../../_static/js/petite-vue.js"></script>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body data-dark_mode_code_blocks="true">

<div id="top_nav">
    

    <nav>
        
            
        

        <p id="toggle_sidebar">
            <a href="#" title="Toggle sidebar">|||</a>
        </p>
        <h1><a href="../../../index.html" title="Go to homepage"><img src="../../../_static/pinder.png"/></a></h1>
            <a id="source_link" href="https://github.com/pinder-org/pinder/">
    
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
            <path fill="white" d="M 244.8,8 C 106.1,8 0,113.3 0,252 c 0,110.9 69.8,205.8 169.5,239.2 12.8,2.3 17.3,-5.6 17.3,-12.1 0,-6.2 -0.3,-40.4 -0.3,-61.4 0,0 -70,15 -84.7,-29.8 0,0 -11.4,-29.1 -27.8,-36.6 0,0 -22.9,-15.7 1.6,-15.4 0,0 24.9,2 38.6,25.8 21.9,38.6 58.6,27.5 72.9,20.9 2.3,-16 8.8,-27.1 16,-33.7 -55.9,-6.2 -112.3,-14.3 -112.3,-110.5 0,-27.5 7.6,-41.3 23.6,-58.9 -2.6,-6.5 -11.1,-33.3 2.6,-67.9 20.9,-6.5 69,27 69,27 20,-5.6 41.5,-8.5 62.8,-8.5 21.3,0 42.8,2.9 62.8,8.5 0,0 48.1,-33.6 69,-27 13.7,34.7 5.2,61.4 2.6,67.9 16,17.7 25.8,31.5 25.8,58.9 0,96.5 -58.9,104.2 -114.8,110.5 9.2,7.9 17,22.9 17,46.4 0,33.7 -0.3,75.4 -0.3,83.6 0,6.5 4.6,14.4 17.3,12.1 C 428.2,457.8 496,362.9 496,252 496,113.3 383.5,8 244.8,8 Z"/>
        </svg>
    
</a>
        

        <a id="mode_toggle" href="#" @click.prevent="handleClick" :title="mode">
    <template v-if="mode == 'light'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_light"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M67.48,18.073c1.913,-1.912 1.913,-5.018 0,-6.931c-1.912,-1.912 -5.018,-1.912 -6.931,0l-6.798,6.799c-1.912,1.912 -1.912,5.018 0,6.931c1.913,1.912 5.018,1.912 6.931,-0l6.798,-6.799Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.728,61.108c1.912,-1.913 1.912,-5.018 -0,-6.931c-1.913,-1.913 -5.019,-1.913 -6.931,-0l-6.799,6.798c-1.912,1.913 -1.912,5.019 0,6.931c1.913,1.913 5.019,1.913 6.931,0l6.799,-6.798Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.682,54.177c-1.913,-1.913 -5.018,-1.913 -6.931,-0c-1.912,1.913 -1.912,5.018 0,6.931l6.798,6.798c1.913,1.913 5.019,1.913 6.931,0c1.913,-1.912 1.913,-5.018 0,-6.931l-6.798,-6.798Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M4.901,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,-0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M18.929,11.142c-1.912,-1.912 -5.018,-1.912 -6.931,0c-1.912,1.913 -1.912,5.019 0,6.931l6.799,6.799c1.912,1.912 5.018,1.912 6.931,-0c1.912,-1.913 1.912,-5.019 -0,-6.931l-6.799,-6.799Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.108,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c-0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c-0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'dark'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_dark"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.901,2.196 -4.901,4.901c0,2.705 2.197,4.901 4.901,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.662,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.989,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.732,61.103c1.91,-1.91 1.91,-5.011 0,-6.921l-0.009,-0.01c-1.91,-1.91 -5.012,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.909,1.91 5.011,1.91 6.92,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.672,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.52,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l-0,-0.01c-0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.901,2.196 -4.901,4.901c0,2.704 2.197,4.9 4.901,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.73,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 -0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.098,34.623c-2.699,0 -4.891,2.192 -4.891,4.892l-0,0.019c-0,2.699 2.192,4.891 4.891,4.891c2.7,0 4.892,-2.192 4.892,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.892,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'darkest'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_darkest"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><path d="M39.315,23.791c8.684,-0 15.734,7.05 15.734,15.733c0,8.684 -7.05,15.734 -15.734,15.734c-8.683,0 -15.733,-7.05 -15.733,-15.734c-0,-8.683 7.05,-15.733 15.733,-15.733Zm0,4.737c6.069,0 10.997,4.927 10.997,10.996c-0,6.069 -4.928,10.996 -10.997,10.996c-6.068,0 -10.996,-4.927 -10.996,-10.996c0,-6.069 4.928,-10.996 10.996,-10.996Z" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.216,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.9,2.196 -4.9,4.901c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.666,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.99,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.737,61.103c1.909,-1.91 1.909,-5.011 -0,-6.921l-0.01,-0.01c-1.91,-1.91 -5.011,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.91,1.91 5.011,1.91 6.921,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.676,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.524,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l0,-0.01c0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.216,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901c-0,2.704 2.196,4.9 4.9,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.734,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.103,34.623c-2.7,0 -4.892,2.192 -4.892,4.892l-0,0.019c-0,2.699 2.192,4.891 4.892,4.891c2.699,0 4.891,-2.192 4.891,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.891,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>
</a>

<script>
(function() {
    const LOCAL_STORAGE_KEY = 'piccoloThemeMode'

    var initialMode = localStorage.getItem(LOCAL_STORAGE_KEY)

    if (initialMode) {
        // Make sure the value in local storage is valid
        if (['light', 'dark', 'darkest'].indexOf(initialMode) == -1) {
            initialMode = 'light'
            localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
        }
    } else {
        // Check if the client prefers dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            initialMode = 'dark'
        } else {
            initialMode = 'light'
        }
        localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
    }

    document.documentElement.dataset.mode = initialMode

    PetiteVue.createApp({
        'mode': initialMode,
        handleClick() {
            let currentMode = this.mode

            if (currentMode == 'light') {
                this.mode = 'dark'
            } else if (currentMode == 'dark') {
                this.mode = 'darkest'
            } else if (currentMode == 'darkest') {
                this.mode = 'light'
            }

            document.documentElement.dataset.mode = this.mode
            localStorage.setItem(LOCAL_STORAGE_KEY, this.mode)

            console.log(this.mode)
        }
    }).mount('#mode_toggle')
})()
</script>
            <p class="mobile_search_link">
                <a href="../../../search.html" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 65 64" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
                        <path d="M14.873 40.009c-2.315-3.943-3.642-8.532-3.642-13.429C11.231 11.91 23.141 0 37.811 0s26.58 11.91 26.58 26.58-11.91 26.58-26.58 26.58a26.44 26.44 0 0 1-14.277-4.161L9.739 62.794a3.12 3.12 0 0 1-4.413 0L.913 58.382c-1.217-1.218-1.217-3.196 0-4.413l13.96-13.96zM37.811 8.054c10.225 0 18.526 8.301 18.526 18.526s-8.301 18.526-18.526 18.526-18.526-8.301-18.526-18.526S27.586 8.054 37.811 8.054z" fill="#fff" />
                    </svg>
                </a>
            </p>
        

        <div class="searchbox_wrapper">
            
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
    </nav>
</div>

    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../readme_link.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/pinder.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example_readme.html">Pinder abstractions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq_link.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../limitations_link.html">Limitations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog_link.html">Dataset changelog</a></li>
</ul>

        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pinder.data.find_transitive_hits</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="n">combinations_with_replacement</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">pinder.data.graph_utils</span> <span class="k">as</span> <span class="nn">gu</span>
<span class="kn">from</span> <span class="nn">pinder.core.index.utils</span> <span class="kn">import</span> <span class="n">setup_logger</span>
<span class="kn">from</span> <span class="nn">pinder.core.utils.timer</span> <span class="kn">import</span> <span class="n">timeit</span>
<span class="kn">from</span> <span class="nn">pinder.data.csv_utils</span> <span class="kn">import</span> <span class="n">read_csv_non_default_na</span>
<span class="kn">from</span> <span class="nn">pinder.data.config</span> <span class="kn">import</span> <span class="n">ClusterConfig</span><span class="p">,</span> <span class="n">GraphConfig</span><span class="p">,</span> <span class="n">get_config_hash</span>
<span class="kn">from</span> <span class="nn">pinder.data.get_clusters</span> <span class="kn">import</span> <span class="n">load_cluster_cache</span>
<span class="kn">from</span> <span class="nn">pinder.data.pipeline.constants</span> <span class="kn">import</span> <span class="n">CONSIDER_LEAKED</span>


<span class="n">log</span> <span class="o">=</span> <span class="n">setup_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="get_potential_representatives">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.get_potential_representatives">[docs]</a>
<span class="k">def</span> <span class="nf">get_potential_representatives</span><span class="p">(</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">ClusterConfig</span> <span class="o">=</span> <span class="n">ClusterConfig</span><span class="p">(),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get potential representatives from the metadata based on specified criteria.</span>

<span class="sd">    Args:</span>
<span class="sd">        metadata (pd.DataFrame): The metadata containing information about the dataset.</span>
<span class="sd">        config (ClusterConfig): The `ClusterConfig` object containing config for selecting the test set.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[pd.DataFrame, pd.DataFrame]: A tuple containing two DataFrames:</span>
<span class="sd">            - The first DataFrame contains the potential representatives based on the specified criteria.</span>
<span class="sd">            - The second DataFrame contains the potential representatives after a specific date.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">date</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">query_fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;oligomeric_count == </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">oligomeric_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;method == &#39;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;interface_atom_gaps_4A &lt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">interface_atom_gaps_4A</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;length1 &gt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">min_chain_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;length2 &gt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">min_chain_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;num_atom_types &gt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">min_atom_types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;label == &#39;</span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">prodigy_label</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;resolution &lt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">resolution_thr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;number_of_components_1 == </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">number_of_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;number_of_components_2 == </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">number_of_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;max_var_1 &lt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">max_var_thr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;max_var_2 &lt;= </span><span class="si">{</span><span class="n">config</span><span class="o">.</span><span class="n">max_var_thr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">query_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">query_fields</span><span class="p">])</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query_str</span><span class="p">)</span>
    <span class="n">af2mm_test</span> <span class="o">=</span> <span class="n">test</span><span class="p">[(</span><span class="n">test</span><span class="p">[</span><span class="s2">&quot;date&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">date</span><span class="o">.</span><span class="n">fromisoformat</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">alphafold_cutoff_date</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">test</span><span class="p">,</span> <span class="n">af2mm_test</span></div>



<div class="viewcode-block" id="get_test_conversion_dicts">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.get_test_conversion_dicts">[docs]</a>
<span class="k">def</span> <span class="nf">get_test_conversion_dicts</span><span class="p">(</span>
    <span class="n">test_index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">cluster_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster_id&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the test index data into a set of test system IDs and a dictionary mapping cluster IDs to test system IDs.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        test_index (pandas.DataFrame): The test index data.</span>
<span class="sd">        cluster_key (str, optional): The column name for the cluster ID. Defaults to &quot;cluster_id&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the set of test system IDs and the dictionary mapping cluster IDs to test system IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_system_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">test_index</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">cluster_to_test_systems</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sys_id</span><span class="p">,</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">test_index</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">test_index</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]):</span>
        <span class="n">cluster_to_test_systems</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sys_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">test_system_ids</span><span class="p">,</span> <span class="n">cluster_to_test_systems</span>  <span class="c1"># type: ignore</span></div>



<div class="viewcode-block" id="get_proto_splits_pindex">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.get_proto_splits_pindex">[docs]</a>
<span class="k">def</span> <span class="nf">get_proto_splits_pindex</span><span class="p">(</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">cluster_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster_id&quot;</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">ClusterConfig</span> <span class="o">=</span> <span class="n">ClusterConfig</span><span class="p">(),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the test-train split for the index based on the cluster_id&quot;&quot;&quot;</span>
    <span class="n">filtered_pindex</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span>
        <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="s2">&quot;cluster_id_R&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="s2">&quot;cluster_id_L&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">filtered_pindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> clustered systems in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> index entries&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">test_meta</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_potential_representatives</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
    <span class="n">test_index</span> <span class="o">=</span> <span class="n">filtered_pindex</span><span class="p">[</span><span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">test_meta</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])]</span>

    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Chose </span><span class="si">{</span><span class="n">test_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> potential test systems &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;from </span><span class="si">{</span><span class="n">filtered_pindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> clustered systems.&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">cluster_to_test_systems</span> <span class="o">=</span> <span class="n">get_test_conversion_dicts</span><span class="p">(</span><span class="n">test_index</span><span class="p">,</span> <span class="n">cluster_key</span><span class="p">)</span>

    <span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;split&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">filtered_pindex</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">test_meta</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]),</span> <span class="s2">&quot;split&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;proto-test&quot;</span>
    <span class="p">)</span>
    <span class="n">filtered_pindex</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">test_meta</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]),</span> <span class="s2">&quot;split&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;proto-train&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_pindex</span><span class="p">,</span> <span class="n">cluster_to_test_systems</span></div>



<div class="viewcode-block" id="get_leakage_dict">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.get_leakage_dict">[docs]</a>
<span class="k">def</span> <span class="nf">get_leakage_dict</span><span class="p">(</span>
    <span class="n">pinder_dir</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
    <span class="n">graph_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">ClusterConfig</span> <span class="o">=</span> <span class="n">ClusterConfig</span><span class="p">(),</span>
    <span class="n">graph_config</span><span class="p">:</span> <span class="n">GraphConfig</span> <span class="o">=</span> <span class="n">GraphConfig</span><span class="p">(),</span>
    <span class="n">use_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">af2_transitive_hits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">chk_dir</span> <span class="o">=</span> <span class="n">pinder_dir</span> <span class="o">/</span> <span class="s2">&quot;cluster&quot;</span> <span class="o">/</span> <span class="n">get_config_hash</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">af2_transitive_hits</span><span class="p">:</span>
        <span class="n">thresh_label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">foldseek_af2_difficulty_threshold</span>
        <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">leakage_checkpoint</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">chk_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2">_af2_lddt</span><span class="si">{</span><span class="n">thresh_label</span><span class="si">}</span><span class="s2">_leakage_dict.pkl&quot;</span>
        <span class="p">)</span>
        <span class="n">potential_leaks_chkpt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">chk_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2">_af2_lddt</span><span class="si">{</span><span class="n">thresh_label</span><span class="si">}</span><span class="s2">_potential_leaks.pkl&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">leakage_checkpoint</span> <span class="o">=</span> <span class="n">chk_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2">_leakage_dict.pkl&quot;</span>
        <span class="n">potential_leaks_chkpt</span> <span class="o">=</span> <span class="n">chk_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2">_potential_leaks.pkl&quot;</span>

    <span class="k">if</span> <span class="n">leakage_checkpoint</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="ow">and</span> <span class="n">use_cache</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2"> split leakage search, </span><span class="si">{</span><span class="n">leakage_checkpoint</span><span class="si">}</span><span class="s2"> checkpoint exists...&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">read_csv_non_default_na</span><span class="p">(</span><span class="n">chk_dir</span> <span class="o">/</span> <span class="s2">&quot;index.2.csv.gz&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;pdb_id&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">})</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">read_csv_non_default_na</span><span class="p">(</span>
        <span class="n">pinder_dir</span> <span class="o">/</span> <span class="s2">&quot;metadata.2.csv.gz&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;entry_id&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">filtered_pindex</span><span class="p">,</span> <span class="n">cluster_to_test_systems</span> <span class="o">=</span> <span class="n">get_proto_splits_pindex</span><span class="p">(</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">,</span>
        <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">systems_proto_test</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">filtered_pindex</span><span class="p">[</span><span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;split&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;proto-test&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">systems_proto_train</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">filtered_pindex</span><span class="p">[</span><span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;split&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;proto-train&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="n">foldseek_communities_cache</span> <span class="o">=</span> <span class="n">chk_dir</span> <span class="o">/</span> <span class="s2">&quot;foldseek_communities.pkl&quot;</span>
    <span class="n">graph_clusters</span> <span class="o">=</span> <span class="n">load_cluster_cache</span><span class="p">(</span><span class="n">foldseek_communities_cache</span><span class="p">)</span>
    <span class="n">graph_fp</span> <span class="o">=</span> <span class="n">pinder_dir</span> <span class="o">/</span> <span class="s2">&quot;graphs&quot;</span> <span class="o">/</span> <span class="n">get_config_hash</span><span class="p">(</span><span class="n">graph_config</span><span class="p">)</span>
    <span class="n">mmseqs_graph_pkl</span> <span class="o">=</span> <span class="n">graph_fp</span> <span class="o">/</span> <span class="s2">&quot;cleaned_mmseqs_alignment_graph.pkl&quot;</span>
    <span class="n">foldseek_graph_pkl</span> <span class="o">=</span> <span class="n">graph_fp</span> <span class="o">/</span> <span class="s2">&quot;cleaned_foldseek_alignment_graph.pkl&quot;</span>
    <span class="k">if</span> <span class="n">graph_type</span> <span class="o">==</span> <span class="s2">&quot;foldseek&quot;</span><span class="p">:</span>
        <span class="n">graph_pkl</span> <span class="o">=</span> <span class="n">foldseek_graph_pkl</span>
        <span class="k">if</span> <span class="n">af2_transitive_hits</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">foldseek_af2_difficulty_threshold</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">foldseek_edge_threshold</span>
    <span class="k">elif</span> <span class="n">graph_type</span> <span class="o">==</span> <span class="s2">&quot;mmseqs&quot;</span><span class="p">:</span>
        <span class="n">graph_pkl</span> <span class="o">=</span> <span class="n">mmseqs_graph_pkl</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">mmseqs_edge_threshold</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">load_graph_pickle</span><span class="p">(</span><span class="n">graph_pkl</span><span class="p">)</span>
    <span class="n">n2c</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">get_node_to_cluster_mapping</span><span class="p">(</span><span class="n">graph_clusters</span><span class="p">)</span>
    <span class="n">split_leakage</span> <span class="o">=</span> <span class="n">find_split_leakage</span><span class="p">(</span>
        <span class="n">systems_proto_test</span><span class="p">,</span>
        <span class="n">systems_proto_train</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">n2c</span><span class="p">,</span>
        <span class="n">config</span><span class="o">.</span><span class="n">depth_limit</span><span class="p">,</span>
        <span class="n">edge_threshold</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
        <span class="n">max_node_degree</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">max_node_degree</span><span class="p">,</span>
        <span class="n">potential_leaks_chkpt</span><span class="o">=</span><span class="n">potential_leaks_chkpt</span><span class="p">,</span>
        <span class="n">use_cache</span><span class="o">=</span><span class="n">use_cache</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">leakage_checkpoint</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">split_leakage</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_transitive_hits">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.get_transitive_hits">[docs]</a>
<span class="k">def</span> <span class="nf">get_transitive_hits</span><span class="p">(</span>
    <span class="n">pinder_dir</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
    <span class="n">config</span><span class="p">:</span> <span class="n">ClusterConfig</span> <span class="o">=</span> <span class="n">ClusterConfig</span><span class="p">(),</span>
    <span class="n">graph_config</span><span class="p">:</span> <span class="n">GraphConfig</span> <span class="o">=</span> <span class="n">GraphConfig</span><span class="p">(),</span>
    <span class="n">test_systems_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;test_sys_table.csv&quot;</span><span class="p">,</span>
    <span class="n">deleak_map_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;transitive_hits_mapping.csv&quot;</span><span class="p">,</span>
    <span class="n">use_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">af2_transitive_hits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">chk_dir</span> <span class="o">=</span> <span class="n">pinder_dir</span> <span class="o">/</span> <span class="s2">&quot;cluster&quot;</span> <span class="o">/</span> <span class="n">get_config_hash</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="n">transitive_hits_checkpoint</span> <span class="o">=</span> <span class="n">chk_dir</span> <span class="o">/</span> <span class="n">test_systems_output</span>
    <span class="k">if</span> <span class="n">transitive_hits_checkpoint</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="ow">and</span> <span class="n">use_cache</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Skipping transitive hit search, </span><span class="si">{</span><span class="n">transitive_hits_checkpoint</span><span class="si">}</span><span class="s2"> checkpoint exists...&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">read_csv_non_default_na</span><span class="p">(</span><span class="n">chk_dir</span> <span class="o">/</span> <span class="s2">&quot;index.2.csv.gz&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;pdb_id&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">})</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">read_csv_non_default_na</span><span class="p">(</span>
        <span class="n">pinder_dir</span> <span class="o">/</span> <span class="s2">&quot;metadata.2.csv.gz&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;entry_id&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">filtered_pindex</span><span class="p">,</span> <span class="n">cluster_to_test_systems</span> <span class="o">=</span> <span class="n">get_proto_splits_pindex</span><span class="p">(</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">,</span>
        <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">af2_transitive_hits</span><span class="p">:</span>
        <span class="n">graph_type</span> <span class="o">=</span> <span class="s2">&quot;foldseek&quot;</span>
        <span class="n">thresh_label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">foldseek_af2_difficulty_threshold</span>
        <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">leakage_checkpoint</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">chk_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2">_af2_lddt</span><span class="si">{</span><span class="n">thresh_label</span><span class="si">}</span><span class="s2">_leakage_dict.pkl&quot;</span>
        <span class="p">)</span>
        <span class="n">leakage_checkpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">leakage_checkpoint</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">leakage_checkpoints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">chk_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph_type</span><span class="si">}</span><span class="s2">_leakage_dict.pkl&quot;</span>
            <span class="k">for</span> <span class="n">graph_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;foldseek&quot;</span><span class="p">,</span> <span class="s2">&quot;mmseqs&quot;</span><span class="p">]</span>
        <span class="p">]</span>
    <span class="n">leakage_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chk</span> <span class="ow">in</span> <span class="n">leakage_checkpoints</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chk</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Split leakage checkpoint </span><span class="si">{</span><span class="n">chk</span><span class="si">}</span><span class="s2"> not found! Generating split leakage...&quot;</span>
            <span class="p">)</span>
            <span class="n">graph_type</span> <span class="o">=</span> <span class="n">chk</span><span class="o">.</span><span class="n">stem</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_leakage_dict&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_af2_lddt&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">get_leakage_dict</span><span class="p">(</span>
                <span class="n">pinder_dir</span><span class="o">=</span><span class="n">pinder_dir</span><span class="p">,</span>
                <span class="n">graph_type</span><span class="o">=</span><span class="n">graph_type</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span>
                <span class="n">graph_config</span><span class="o">=</span><span class="n">graph_config</span><span class="p">,</span>
                <span class="n">use_cache</span><span class="o">=</span><span class="n">use_cache</span><span class="p">,</span>
                <span class="n">af2_transitive_hits</span><span class="o">=</span><span class="n">af2_transitive_hits</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">chk</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">split_leakage</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">leakage_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_leakage</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished loading leakage_dicts&quot;</span><span class="p">)</span>
    <span class="n">system_hits_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
        <span class="n">deep_merge_dict</span><span class="p">,</span> <span class="n">leakage_dicts</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">system_hits_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">self_system</span><span class="p">,</span> <span class="n">target_systems</span> <span class="ow">in</span> <span class="n">system_hits_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">system_hits_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">self_system</span><span class="p">,</span>
                <span class="s2">&quot;neighbors&quot;</span><span class="p">:</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">target_systems</span><span class="p">)),</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="n">system_hits_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">system_hits_list</span><span class="p">)</span>
    <span class="n">system_hits_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">chk_dir</span> <span class="o">/</span> <span class="n">deleak_map_output</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">system_hits_dict_clean_num</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">system_hits_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">CONSIDER_LEAKED</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">system_hits_dict_clean_num</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">system_hits_dict_clean_num</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">system_to_dg1_clust</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">test_systems</span> <span class="ow">in</span> <span class="n">cluster_to_test_systems</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">test_system</span> <span class="ow">in</span> <span class="n">test_systems</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test_system</span> <span class="ow">in</span> <span class="n">system_hits_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">CONSIDER_LEAKED</span> <span class="ow">in</span> <span class="n">system_hits_dict</span><span class="p">[</span><span class="n">test_system</span><span class="p">]:</span>
                    <span class="n">system_to_dg1_clust</span><span class="p">[</span><span class="n">test_system</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">system_to_dg1_clust</span><span class="p">[</span><span class="n">test_system</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                        <span class="n">system_hits_dict</span><span class="p">[</span><span class="n">test_system</span><span class="p">]</span> <span class="o">|</span> <span class="n">test_systems</span>
                    <span class="p">)</span>

    <span class="c1"># unused</span>
    <span class="c1"># test_system_to_clust = {}</span>
    <span class="c1"># for cluster_id, test_systems in cluster_to_test_systems.items():</span>
    <span class="c1">#     for test_system in test_systems:</span>
    <span class="c1">#         test_system_to_clust[test_system] = test_systems</span>

    <span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;depth_2_hits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">system_hits_dict_clean_num</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;depth_2_hits_with_comm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">system_to_dg1_clust</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">test_sys_table</span> <span class="o">=</span> <span class="n">filtered_pindex</span><span class="p">[</span><span class="n">filtered_pindex</span><span class="p">[</span><span class="s2">&quot;split&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;proto-test&quot;</span><span class="p">]</span>
    <span class="n">test_sys_table</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">transitive_hits_checkpoint</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="cluster_leaks">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.cluster_leaks">[docs]</a>
<span class="k">def</span> <span class="nf">cluster_leaks</span><span class="p">(</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">node_to_cluster</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all nodes x in a graph such that:</span>
<span class="sd">        1. there exists a path of length l &lt;= &lt;depth&gt; from source to x</span>
<span class="sd">        2. source and x are in different clusters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source: str</span>
<span class="sd">        The source node</span>
<span class="sd">    graph: nx.Graph</span>
<span class="sd">        The target graph. Must contain &lt;node&gt;</span>
<span class="sd">    node_to_cluster: Dict[str, int]</span>
<span class="sd">        Map from nodes to cluster IDs</span>
<span class="sd">    depth: int</span>
<span class="sd">        Maximum allowed path length.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Set[str]</span>
<span class="sd">        The set of nodes in the &quot;&lt;depth&gt;-neighborhood&quot; of source</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_cluster</span> <span class="o">=</span> <span class="n">node_to_cluster</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">neighbor_nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_shortest_path_length</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">depth</span>
    <span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">neighbor_nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodes</span></div>



<div class="viewcode-block" id="batch_cluster_leaks">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.batch_cluster_leaks">[docs]</a>
<span class="nd">@timeit</span>
<span class="k">def</span> <span class="nf">batch_cluster_leaks</span><span class="p">(</span>
    <span class="n">source_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">node_to_cluster</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">max_node_degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">1_000</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find cluster leaks for all nodes in node_set.</span>

<span class="sd">    For each node, finds the set of all neighbors in graph within depth</span>
<span class="sd">    hops of node that are in different clusters.</span>

<span class="sd">    Applies checks to limit computation. If a node fails any</span>
<span class="sd">    check, the corresponding value will be CONSIDER_LEAKED.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_set: Set[str]</span>
<span class="sd">        A set of target sources</span>
<span class="sd">    graph: nx.Graph</span>
<span class="sd">        The target graph. Must contain all nodes in &lt;node_set&gt;</span>
<span class="sd">    node_to_cluster: Dict[str, int]</span>
<span class="sd">        Map from nodes to cluster IDs</span>
<span class="sd">    depth: int</span>
<span class="sd">        Maximum allowed path length.</span>
<span class="sd">    max_node_degree: int</span>
<span class="sd">        Maximum allowed node degree. Default 1000</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict[str, Set[str]]</span>
<span class="sd">        Mapping from a node to the set of nodes in the</span>
<span class="sd">        node&#39;s &quot;&lt;depth&gt;-neighborhood&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First determine for which nodes we can avoid finding paths</span>
    <span class="k">if</span> <span class="n">max_node_degree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">source_set</span><span class="p">))</span>
        <span class="n">failing_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">passing_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="n">degrees</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Extracting nodes within max_node_degree=</span><span class="si">{</span><span class="n">max_node_degree</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">max_node_degree</span><span class="p">:</span>
                <span class="n">passing_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">failing_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">passing_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source_set</span><span class="p">)</span>
        <span class="n">failing_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Compute the neighbors</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">passing_nodes</span><span class="p">):</span>
        <span class="n">source_match</span> <span class="o">=</span> <span class="n">cluster_leaks</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">node_to_cluster</span><span class="o">=</span><span class="n">node_to_cluster</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span>
        <span class="p">)</span>
        <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_match</span><span class="p">)</span>

    <span class="c1"># Build the dictionary</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">passing_nodes</span><span class="p">,</span> <span class="n">matches</span><span class="p">))</span> <span class="o">|</span> <span class="p">{</span>
        <span class="n">n</span><span class="p">:</span> <span class="p">{</span><span class="n">CONSIDER_LEAKED</span><span class="p">}</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">failing_nodes</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="get_leak_map_for_id">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.get_leak_map_for_id">[docs]</a>
<span class="k">def</span> <span class="nf">get_leak_map_for_id</span><span class="p">(</span>
    <span class="n">pure_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">pure_map_forward</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="n">pure_map_backward</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">corrupt_map_backward</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">all_pure_pairs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">all_corrupt_pairs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">potential_leaks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Do the multi-step mapping from:</span>
<span class="sd">    pure system -&gt; pure pair of nodes</span>
<span class="sd">    pure pair of nodes -&gt; possibly corrupt leaks for each node</span>
<span class="sd">    possibly corrupt leaks -&gt; corrupt systems (by intersection)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">pure_map_forward</span><span class="p">[</span><span class="n">pure_id</span><span class="p">]</span>
    <span class="n">v_leaks</span> <span class="o">=</span> <span class="n">potential_leaks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>  <span class="c1"># Say this has size n</span>
    <span class="n">u_leaks</span> <span class="o">=</span> <span class="n">potential_leaks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>  <span class="c1"># Say this has size m</span>
    <span class="c1"># Possible that one or more of the nodes was skipped</span>
    <span class="k">if</span> <span class="n">CONSIDER_LEAKED</span> <span class="ow">in</span> <span class="n">v_leaks</span> <span class="ow">or</span> <span class="n">CONSIDER_LEAKED</span> <span class="ow">in</span> <span class="n">u_leaks</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">CONSIDER_LEAKED</span><span class="p">}</span>
    <span class="c1"># potential_leak_pairs = filtered_product(v_leaks, u_leaks, all_corrupt_pairs)</span>
    <span class="n">check_pairs</span> <span class="o">=</span> <span class="n">all_corrupt_pairs</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">all_pure_pairs</span><span class="p">)</span>
    <span class="c1"># O(min(n*m, k)), where k = |check_pairs|</span>
    <span class="n">potential_leak_pairs</span> <span class="o">=</span> <span class="n">intersection_unordered_product</span><span class="p">(</span><span class="n">v_leaks</span><span class="p">,</span> <span class="n">u_leaks</span><span class="p">,</span> <span class="n">check_pairs</span><span class="p">)</span>
    <span class="n">corrupt</span> <span class="o">=</span> <span class="p">[</span><span class="n">corrupt_map_backward</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">potential_leak_pairs</span><span class="p">]</span>
    <span class="n">corrupt_test</span> <span class="o">=</span> <span class="p">[</span><span class="n">pure_map_backward</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">potential_leak_pairs</span><span class="p">]</span>
    <span class="n">corrupt</span> <span class="o">=</span> <span class="n">corrupt</span> <span class="o">+</span> <span class="n">corrupt_test</span>
    <span class="n">pairs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="n">corrupt</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">pairs</span></div>



<div class="viewcode-block" id="map_leak_pairs">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.map_leak_pairs">[docs]</a>
<span class="nd">@timeit</span>
<span class="k">def</span> <span class="nf">map_leak_pairs</span><span class="p">(</span>
    <span class="n">pure_split</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">pure_map_forward</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="n">pure_map_backward</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">corrupt_map_backward</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">all_pure_pairs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">all_corrupt_pairs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">potential_leaks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="n">mapped_pairs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">pure_id</span><span class="p">:</span> <span class="n">get_leak_map_for_id</span><span class="p">(</span>
            <span class="n">pure_id</span><span class="p">,</span>
            <span class="n">pure_map_forward</span><span class="p">,</span>
            <span class="n">pure_map_backward</span><span class="p">,</span>
            <span class="n">corrupt_map_backward</span><span class="p">,</span>
            <span class="n">all_pure_pairs</span><span class="p">,</span>
            <span class="n">all_corrupt_pairs</span><span class="p">,</span>
            <span class="n">potential_leaks</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">pure_id</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">pure_split</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Mapping potential leakage pairs per ID&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">mapped_pairs</span></div>



<div class="viewcode-block" id="find_split_leakage">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.find_split_leakage">[docs]</a>
<span class="k">def</span> <span class="nf">find_split_leakage</span><span class="p">(</span>
    <span class="n">pure_split</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">corrupt_split</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">graph</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span>
    <span class="n">node_to_cluster</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">edge_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.65</span><span class="p">,</span>
    <span class="n">max_node_degree</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1_000</span><span class="p">,</span>
    <span class="n">potential_leaks_chkpt</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find leakage between transitive neighbors of two putative splits.</span>

<span class="sd">    For systems in pure_split, determine whether there are systems in</span>
<span class="sd">    corrupt_split that leak into the pure_split.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        pure_split : Set[str]</span>
<span class="sd">            The set of PINDER System IDs in the pure split (e.g., test).</span>
<span class="sd">        corrupt_split : Set[str]</span>
<span class="sd">            The set of PINDER System IDs in the corrupt split (e.g., train).</span>
<span class="sd">        graph : nx.Graph</span>
<span class="sd">            The foldseek-similarity monomer graph.</span>
<span class="sd">        node_to_cluster : Dict[str, int]</span>
<span class="sd">            The map from graph nodes to cluster IDs.</span>
<span class="sd">        depth : int</span>
<span class="sd">            The maximum path length to travel looking for leakage.</span>
<span class="sd">        edge_threshold : float, optional</span>
<span class="sd">            The threshold for considering edges in the graph. Default is 0.65.</span>
<span class="sd">        max_node_degree : int, optional</span>
<span class="sd">            The node degree at which we assume there is leakage. This is</span>
<span class="sd">            to save compute. Default is 1000.</span>
<span class="sd">        potential_leaks_chkpt : Path, optional</span>
<span class="sd">            The path to checkpoint potential leaks. Default is None.</span>
<span class="sd">        use_cache : bool, optional</span>
<span class="sd">            Whether to use cached results. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict[str, Set[str]]</span>
<span class="sd">            The map from pure_split IDs to corrupt_split IDs, indicating leakage.</span>

<span class="sd">    Note:</span>
<span class="sd">        A system `c:= {u, v}` in `corrupt_split` is a leaking system for system</span>
<span class="sd">        `p:= {s, t}` in `pure_split` iff any of the following are true:</span>

<span class="sd">            1. All of the following are true:</span>
<span class="sd">                - `u` and `s` are in different clusters</span>
<span class="sd">                - There exists a path between `u` and `s` of length &lt;= `depth`</span>
<span class="sd">                - `v` and `t` are in different clusters</span>
<span class="sd">                - There exists a path between `v` and `t` of length &lt;= `depth`</span>

<span class="sd">            2. All of the following are true:</span>
<span class="sd">                - `u` and `t` are in different clusters</span>
<span class="sd">                - There exists a path between `u` and `t` of length &lt;= `depth`</span>
<span class="sd">                - `v` and `s` are in different clusters</span>
<span class="sd">                - There exists a path between `v` and `s` of length &lt;= `depth`</span>

<span class="sd">        Method sequence:</span>

<span class="sd">            1. Create a map from test systems to graph node pairs</span>
<span class="sd">            2. Do any filtering required on the graph</span>
<span class="sd">            3. Find cluster_leaks for all nodes in these pairs</span>
<span class="sd">            4. For train systems, create a nested map from graph node pairs to sets of train systems</span>
<span class="sd">            5. For each system x in test:</span>
<span class="sd">                a. Map x to a graph test pair</span>
<span class="sd">                b. Find all graph train pairs containing at least one member of the graph test pair using the &quot;adjacency map&quot;</span>
<span class="sd">                c. Map from these graph train pairs to train systems</span>
<span class="sd">                d. These are the inter_split connections</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">## We will need two maps. Ahoy!</span>
    <span class="n">pure_map_forward</span> <span class="o">=</span> <span class="n">map_systems_to_fsid_pairs</span><span class="p">(</span><span class="n">pure_split</span><span class="p">)</span>
    <span class="n">corrupt_map_backward</span> <span class="o">=</span> <span class="n">map_fsid_pair_to_systems</span><span class="p">(</span><span class="n">corrupt_split</span><span class="p">)</span>
    <span class="n">pure_map_backward</span> <span class="o">=</span> <span class="n">map_fsid_pair_to_systems</span><span class="p">(</span><span class="n">pure_split</span><span class="p">)</span>

    <span class="c1"># Useful to also have the set of all node pairs associated with corrupt set</span>
    <span class="n">all_corrupt_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">corrupt_map_backward</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">all_pure_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pure_map_backward</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># Filter the graph, if necessary</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># TODO: filtering this way does not play nicely with multiprocessing</span>
    <span class="n">subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph_view</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">filter_edge</span><span class="o">=</span><span class="k">lambda</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">edge_threshold</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;graph filtering succeeded: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

    <span class="c1"># Find potential leaks</span>
    <span class="n">all_pure_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pure_map_forward</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">potential_leaks_chkpt</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">potential_leaks_chkpt</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">use_cache</span>
    <span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">potential_leaks_chkpt</span><span class="si">}</span><span class="s2"> found, skipping batch_cluster_leaks...&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">potential_leaks_chkpt</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">potential_leaks</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">potential_leaks</span> <span class="o">=</span> <span class="n">batch_cluster_leaks</span><span class="p">(</span>
            <span class="n">all_pure_nodes</span><span class="p">,</span>
            <span class="n">subgraph</span><span class="p">,</span>
            <span class="n">node_to_cluster</span><span class="p">,</span>
            <span class="n">depth</span><span class="p">,</span>
            <span class="n">max_node_degree</span><span class="o">=</span><span class="n">max_node_degree</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">potential_leaks_chkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">potential_leaks_chkpt</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">potential_leaks</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="n">mapped_pairs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">map_leak_pairs</span><span class="p">(</span>
        <span class="n">pure_split</span><span class="o">=</span><span class="n">pure_split</span><span class="p">,</span>
        <span class="n">pure_map_forward</span><span class="o">=</span><span class="n">pure_map_forward</span><span class="p">,</span>
        <span class="n">pure_map_backward</span><span class="o">=</span><span class="n">pure_map_backward</span><span class="p">,</span>
        <span class="n">corrupt_map_backward</span><span class="o">=</span><span class="n">corrupt_map_backward</span><span class="p">,</span>
        <span class="n">all_pure_pairs</span><span class="o">=</span><span class="n">all_pure_pairs</span><span class="p">,</span>
        <span class="n">all_corrupt_pairs</span><span class="o">=</span><span class="n">all_corrupt_pairs</span><span class="p">,</span>
        <span class="n">potential_leaks</span><span class="o">=</span><span class="n">potential_leaks</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">mapped_pairs</span></div>



<div class="viewcode-block" id="map_systems_to_fsid_pairs">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.map_systems_to_fsid_pairs">[docs]</a>
<span class="nd">@timeit</span>
<span class="k">def</span> <span class="nf">map_systems_to_fsid_pairs</span><span class="p">(</span><span class="n">system_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a map from PINDER System ID strings to pairs of Foldseek monomer ID strings&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="n">gu</span><span class="o">.</span><span class="n">system_id_to_fsid_pair</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">system_ids</span><span class="p">}</span></div>



<div class="viewcode-block" id="map_fsid_pair_to_systems">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.map_fsid_pair_to_systems">[docs]</a>
<span class="nd">@timeit</span>
<span class="k">def</span> <span class="nf">map_fsid_pair_to_systems</span><span class="p">(</span><span class="n">system_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a hierarchical map from Foldseek monomer ID pairs to PINDER System IDs</span>

<span class="sd">    This map is insensitive to order.</span>
<span class="sd">    Avoid using defaultdict, which is actually quite slow</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fsid_pair_to_systems</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">system_ids</span><span class="p">:</span>
        <span class="c1"># Technically, this can be a singleton, but that&#39;s ok</span>
        <span class="n">unordered_pair</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">gu</span><span class="o">.</span><span class="n">system_id_to_fsid_pair</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">unordered_pair</span> <span class="ow">in</span> <span class="n">fsid_pair_to_systems</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">fsid_pair_to_systems</span><span class="p">[</span><span class="n">unordered_pair</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Add the items</span>
        <span class="n">fsid_pair_to_systems</span><span class="p">[</span><span class="n">unordered_pair</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fsid_pair_to_systems</span></div>



<div class="viewcode-block" id="deep_merge_dict">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.deep_merge_dict">[docs]</a>
<span class="k">def</span> <span class="nf">deep_merge_dict</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge two dictionaries in which values are Set objects using `set.update`&quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="intersection_unordered_product">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.intersection_unordered_product">[docs]</a>
<span class="k">def</span> <span class="nf">intersection_unordered_product</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">B</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">C</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the intersection between C and the unordered set product of A and B:= U.</span>

<span class="sd">    Attempts to do this efficiently by determining the size of U before actually</span>
<span class="sd">    computing U, then iterating over the smaller of U or C, while checking inclusion</span>
<span class="sd">    in the larger.</span>

<span class="sd">    Specifically:</span>
<span class="sd">        1. determines the size of U, the unordered cartesian product of A and B</span>
<span class="sd">        2. if U is smaller than C, computes U and iterates over it, checking inclusion</span>
<span class="sd">           in C.</span>
<span class="sd">        3. if U is larger than C, iterates over C and checks inclusion in A and B.</span>

<span class="sd">    NB: our elements are of size 1 or 2, so to check inclusion we use 0 or -1 as our</span>
<span class="sd">    indices. If our elements were of another size, this code would not work!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A: set[str]</span>
<span class="sd">        The first set in the possible product</span>
<span class="sd">    B: set[str]</span>
<span class="sd">        The second set in the possible product</span>
<span class="sd">    C: set[frozenset[str]]</span>
<span class="sd">        The set that we are intersecting with A x B</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set[frozenset[str]</span>
<span class="sd">        The set intersection between C and AxB (unordered)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">len_unordered_set_product</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">unordered_set_product</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="k">if</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">C</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="nb">frozenset</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">C</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">B</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A</span> <span class="ow">and</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">B</span><span class="p">)</span>
        <span class="p">}</span></div>



<div class="viewcode-block" id="unordered_set_product">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.unordered_set_product">[docs]</a>
<span class="k">def</span> <span class="nf">unordered_set_product</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">B</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the unordered cartesian product of sets A and B.</span>

<span class="sd">    We define the unordered set product :math:`U` as a subset of :math:`P := A \times B`,</span>
<span class="sd">    where if :math:`x := (a, b)` is in :math:`U`, then :math:`y := (b, a)` is not in :math:`U`,</span>
<span class="sd">    even if :math:`y` is in :math:`P`.</span>

<span class="sd">    The goal of this method is to compute the unordered set product of A and B</span>
<span class="sd">    in the most efficient way possible, ideally without computing the entire product.</span>

<span class="sd">    Given two sets, A and B, with intersection :math:`|A \cap B| := I`, where :math:`|A| = n`,</span>
<span class="sd">    :math:`|B| = m`, and :math:`|I| = i`. The cartesian product of A and B has size :math:`n \\times m`,</span>
<span class="sd">    but the *unordered* cartesian product may be smaller.</span>

<span class="sd">    To compute the unordered cartesian product, we want the union of:</span>

<span class="sd">        - combinations with replacement, length 2 of :math:`I` :math:`\\left( \\binom{i+1}{2} = \\frac{(i+1) \\cdot i}{2} \\right)`</span>
<span class="sd">        - product of :math:`A \setminus I` with :math:`I` :math:`\\left( (n-i) \cdot i \\right)`</span>
<span class="sd">        - product of :math:`B \setminus I` with :math:`I` :math:`\\left( (m-i) \cdot i \\right)`</span>
<span class="sd">        - product of :math:`A \setminus I` with :math:`B \setminus I` :math:`\\left( (n-i) \\cdot (m-i) \\right)`</span>

<span class="sd">    The size of this union is :math:`n \\times m - \\frac{i^2 - i}{2}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : set[str]</span>
<span class="sd">        The first product set.</span>
<span class="sd">    B : set[str]</span>
<span class="sd">        The second product set.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    set[tuple[str]]</span>
<span class="sd">        The unordered cartesian product of A and B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">A_unique</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">I</span>
    <span class="n">B_unique</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">I</span>

    <span class="n">set_prod</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
        <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
        <span class="n">product</span><span class="p">(</span><span class="n">A_unique</span><span class="p">,</span> <span class="n">I</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
        <span class="n">product</span><span class="p">(</span><span class="n">B_unique</span><span class="p">,</span> <span class="n">I</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
        <span class="n">product</span><span class="p">(</span><span class="n">A_unique</span><span class="p">,</span> <span class="n">B_unique</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">set_prod</span></div>



<div class="viewcode-block" id="len_unordered_set_product">
<a class="viewcode-back" href="../../../source/pinder.data.html#pinder.data.find_transitive_hits.len_unordered_set_product">[docs]</a>
<span class="k">def</span> <span class="nf">len_unordered_set_product</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">B</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the size of the unordered cartesian product of sets A and B.</span>

<span class="sd">    We define the unordered set product U as a subset of P:=product(A, B), where if</span>
<span class="sd">    x:=(a,b) is in U, then y:=(b,a) is not in U, even if y is in P.</span>

<span class="sd">    Given two sets, A and B, with intersection :math:`|A \cap B| = I`, where :math:`|A| = n`,</span>
<span class="sd">    :math:`|B| = m`, and :math:`|I| = i`. The cartesian product of A and B has size n*m, but the *unordered*</span>
<span class="sd">    cartesian product may be smaller.</span>

<span class="sd">    To compute the unordered cartesian product, we want the union of:</span>

<span class="sd">        - combinations with replacement, length 2 of :math:`I` :math:`\\left( \\binom{i+1}{2} = \\frac{(i+1) \\cdot i}{2} \\right)`</span>
<span class="sd">        - product of :math:`A \setminus I` with :math:`I` :math:`\\left( (n-i) \cdot i \\right)`</span>
<span class="sd">        - product of :math:`B \setminus I` with :math:`I` :math:`\\left( (m-i) \cdot i \\right)`</span>
<span class="sd">        - product of :math:`A \setminus I` with :math:`B \setminus I` :math:`\\left( (n-i) \\cdot (m-i) \\right)`</span>

<span class="sd">    The size of this union is :math:`n \\times m - \\frac{i^2 - i}{2}`. Note that :math:`(i**2 - i))` is</span>
<span class="sd">    always even for all integer i.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A: set[str]</span>
<span class="sd">        The first product set</span>
<span class="sd">    B: set[str]</span>
<span class="sd">        The second product set</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The size of AxB (unordered)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># Note that i**2 - i is always even for all i</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
    

      <div class="clearer"></div>
    </div>
    <div class="button_nav_wrapper">
        <div class="button_nav">
            <div class="left">
                
            </div>

            <div class="right">
                
            </div>
        </div>
    </div>


    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, VantAI.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>

<p id="theme_credit"></p>
  </body>
</html>